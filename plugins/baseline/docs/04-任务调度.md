# Elkeid Baseline 插件 - 任务调度设计

## 目录
- [调度概述](#调度概述)
- [按需扫描](#按需扫描)
- [定时扫描](#定时扫描)
- [并发控制](#并发控制)
- [任务生命周期](#任务生命周期)
- [调优建议](#调优建议)

---

## 调度概述

Baseline 插件支持两种任务调度模式，满足不同的使用场景。

### 调度模式

| 模式 | 触发方式 | 使用场景 | 优先级 |
|------|---------|---------|--------|
| 按需扫描 | Elkeid Server 下发任务 | 应急响应、合规检查 | 高 |
| 定时扫描 | 每日自动执行 | 日常巡检、持续监控 | 低 |

### 架构图

```
┌──────────────────────────────────────────────────────────┐
│                    Main Process                           │
│                                                           │
│  ┌────────────────────────────────────────────────┐     │
│  │         Task Receiver Goroutine                │     │
│  │  (按需扫描)                                     │     │
│  │  ┌──────────────────────────────────────┐     │     │
│  │  │  for {                                │     │     │
│  │  │    task = ReceiveTask()               │     │     │
│  │  │    go processTask(task)  // 异步处理  │     │     │
│  │  │  }                                    │     │     │
│  │  └──────────────────────────────────────┘     │     │
│  └────────────────────────────────────────────────┘     │
│                                                           │
│  ┌────────────────────────────────────────────────┐     │
│  │         Daily Cronjob Goroutine                │     │
│  │  (定时扫描)                                     │     │
│  │  ┌──────────────────────────────────────┐     │     │
│  │  │  ticker = NewTicker(24h)              │     │     │
│  │  │  for {                                │     │     │
│  │  │    <-ticker.C                         │     │     │
│  │  │    randomDelay()                      │     │     │
│  │  │    baselineId = getDefault()          │     │     │
│  │  │    Analysis(baselineId)               │     │     │
│  │  │  }                                    │     │     │
│  │  └──────────────────────────────────────┘     │     │
│  └────────────────────────────────────────────────┘     │
│                                                           │
│  Resource Limit: GOMAXPROCS(4)                           │
└──────────────────────────────────────────────────────────┘
```

---

## 按需扫描

### 触发机制

由 Elkeid Server 通过 Plugin SDK 下发任务。

### 任务数据格式

```json
{
    "baseline_id": 1200,
    "check_id_list": [1, 2, 3, 10, 20]
}
```

**字段说明**:
- `baseline_id`: 要执行的基线ID
- `check_id_list`: 检查项ID列表
  - 空数组 `[]`: 执行该基线的所有检查项
  - 非空数组: 只执行指定的检查项

### 实现代码

**任务接收器** (`main.go:76-104`):

```go
// 独立 Goroutine 持续监听任务
go func() {
    for {
        // 1. 从 Elkeid Agent 接收任务
        pluginsTask, err := pluginClient.ReceiveTask()
        if err != nil {
            infra.Loger.Println("getTask error:", err.Error())
            break
        }

        // 2. 为每个任务启动独立 Goroutine 异步处理
        go func() {
            // 3. 执行基线分析
            retBaselineInfo, analysisErr := check.Analysis(pluginsTask.Data)

            // 4. 上报结果到 Server (DataType: 8000)
            err = SendServer(retBaselineInfo, pluginsTask.Token)
            if err != nil {
                infra.Loger.Println("sendServer error:", err)
            } else {
                infra.Loger.Println("sendServer success:", retBaselineInfo.BaselineId)
            }

            // 5. 上报任务状态 (DataType: 8010)
            if analysisErr != nil {
                TaskStatusSendServer(TaskStatusFailed, pluginsTask.Token, analysisErr.Error())
            } else {
                TaskStatusSendServer(TaskStatusSuccess, pluginsTask.Token, "")
            }
        }()
    }
}()
```

### 执行流程

```
1. Elkeid Server 下发任务
   ↓
2. Plugin SDK 接收任务
   pluginClient.ReceiveTask()
   ↓
3. 解析任务数据
   JSON → TaskData{baseline_id, check_id_list}
   ↓
4. 加载基线配置
   getBaselineConfigData(baseline_id)
   ↓
5. 执行检查项
   for checkInfo in CheckList {
       AnalysisRule(checkInfo.Check)
   }
   ↓
6. 格式化结果
   RetBaselineInfo{check_list: [...]}
   ↓
7. 上报结果
   SendServer(result, token)
   ↓
8. 上报状态
   TaskStatusSendServer(status, token)
```

### 并发模型

**特点**:
- 每个任务在独立 Goroutine 中处理
- 任务之间相互隔离
- 不会阻塞任务接收器

**示例场景**:

```
t=0s:  Server 下发任务 A (baseline_id=1200, check_ids=[1,2,3])
       → 启动 Goroutine 1 处理

t=1s:  Server 下发任务 B (baseline_id=1300, check_ids=[1,2])
       → 启动 Goroutine 2 处理

t=2s:  Goroutine 1 完成，上报结果
t=3s:  Goroutine 2 完成，上报结果
```

### 使用示例

**场景1: 应急检查**

```json
{
    "baseline_id": 1200,
    "check_id_list": [50, 51, 52]  // 只检查文件权限相关项
}
```

**场景2: 全量检查**

```json
{
    "baseline_id": 1200,
    "check_id_list": []  // 执行所有检查项
}
```

**场景3: 合规检查**

```json
{
    "baseline_id": 1200,
    "check_id_list": [1,2,3,4,5,6,7,8,9,10]  // 只检查密码策略相关项
}
```

---

## 定时扫描

### 调度策略

**执行频率**: 每日一次

**执行时间**: 0:00-6:00 之间的随机时间

**为什么随机？**
- 分散服务器负载
- 避免多台机器同时扫描
- 降低对生产环境的影响

### 实现代码

**定时调度器** (`main.go:106-152`):

```go
// 初始化: 计算到明天 0-6 点之间随机时间的延迟
init := true
dailyTicker := time.NewTicker(
    time.Until(
        time.Date(
            time.Now().Year(),
            time.Now().Month(),
            time.Now().Day()+1,  // 明天
            rand.Intn(6),        // 0-5 点（随机）
            rand.Intn(60),       // 0-59 分（随机）
            rand.Intn(60),       // 0-59 秒（随机）
            0,
            time.Now().Location(),
        )
    )
)

defer dailyTicker.Stop()

for {
    select {
    case <-dailyTicker.C:
        // 首次执行后重置为 24 小时间隔
        if init {
            dailyTicker.Reset(time.Hour * 24)
            init = false
        }

        // 1. 根据操作系统类型选择默认基线
        var baselineIdList []int
        switch linux.GetSystemType() {
        case "centos":
            baselineIdList = CentosDefaultList  // [1200]
        case "debian":
            baselineIdList = DebianDefaultList  // [1300]
        case "ubuntu":
            baselineIdList = UbuntuDefaultList  // [1400]
        default:
            return
        }

        // 2. 执行扫描
        for _, baselineId := range baselineIdList {
            retBaselineInfo, analysisErr := check.Analysis(baselineId)

            // 3. 上报结果（无 token）
            err := SendServer(retBaselineInfo, "")
            if err != nil {
                infra.Loger.Println("sendServer error", err)
            } else {
                infra.Loger.Println("sendServer success:", retBaselineInfo)
            }

            // 4. 上报状态（无 token）
            if analysisErr != nil {
                TaskStatusSendServer(TaskStatusFailed, "", analysisErr.Error())
            } else {
                TaskStatusSendServer(TaskStatusSuccess, "", "")
            }
        }
    }
}
```

### 随机延迟算法

**目标**: 在 0:00-6:00 之间均匀分布

**实现**:

```go
// 计算到明天指定时间的延迟
targetTime := time.Date(
    time.Now().Year(),
    time.Now().Month(),
    time.Now().Day()+1,    // 明天
    rand.Intn(6),          // 小时: 0-5 (即 0:00-5:59)
    rand.Intn(60),         // 分钟: 0-59
    rand.Intn(60),         // 秒: 0-59
    0,                     // 纳秒
    time.Now().Location(), // 时区
)

delay := time.Until(targetTime)
```

**示例执行时间**:
- 机器 A: 02:15:37
- 机器 B: 00:42:11
- 机器 C: 05:08:52
- 机器 D: 03:31:25

### 默认基线

| 操作系统 | 默认基线 ID | 检查项数量 |
|---------|------------|-----------|
| CentOS | 1200 | ~120 |
| Debian | 1300 | ~120 |
| Ubuntu | 1400 | ~120 |

**配置** (`main.go:19-21`):

```go
var (
    CentosDefaultList = []int{1200}
    DebianDefaultList = []int{1300}
    UbuntuDefaultList = []int{1400}
)
```

**修改默认基线**:

如需修改默认基线，编辑 `main.go` 并重新编译：

```go
// 修改为自定义基线
var (
    CentosDefaultList = []int{1250}  // 自定义 CentOS 基线
    DebianDefaultList = []int{1300}
    UbuntuDefaultList = []int{1400}
)
```

### 操作系统检测

**实现** (`os_system.go`):

```go
func GetSystemType() string {
    // 读取 /etc/issue 文件
    file, err := os.Open("/etc/issue")
    if err != nil {
        return "centos"  // 默认
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)
    if scanner.Scan() {
        line := strings.ToLower(scanner.Text())

        // 关键字匹配
        if strings.Contains(line, "ubuntu") {
            return "ubuntu"
        } else if strings.Contains(line, "debian") {
            return "debian"
        }
    }

    return "centos"  // 默认
}
```

**示例 /etc/issue 内容**:

```
# CentOS
CentOS Linux 7 (Core)

# Ubuntu
Ubuntu 20.04.3 LTS

# Debian
Debian GNU/Linux 10
```

---

## 并发控制

### CPU 限制

**配置** (`main.go:26`):

```go
func init() {
    runtime.GOMAXPROCS(4)  // 最多使用 4 个 CPU 核心
    pluginClient = plugins.New()
}
```

**为什么限制为 4 核？**

1. **避免资源竞争**: 基线扫描非实时任务，无需高并发
2. **保护生产环境**: 避免占用过多 CPU 影响业务
3. **稳定性优先**: 控制资源使用，降低系统负载

### Goroutine 管理

**并发模型**:

```
Main Process
├── Goroutine 1: Task Receiver (常驻)
│   ├── Goroutine 1.1: Process Task A
│   ├── Goroutine 1.2: Process Task B
│   └── Goroutine 1.3: Process Task C
│
└── Goroutine 2: Daily Cronjob (常驻)
    └── Execute baseline scan (同步执行)
```

**特点**:
- **任务接收器**: 独立 Goroutine，常驻运行
- **任务处理**: 每个任务一个 Goroutine，异步执行
- **定时扫描**: 独立 Goroutine，同步执行（不再创建子 Goroutine）

### 资源隔离

**按需扫描与定时扫描**:
- 两者在不同 Goroutine 中运行
- 互不影响
- 共享 CPU 资源限制（GOMAXPROCS=4）

**多任务并发**:
- 按需任务可以并发执行
- 定时任务串行执行（一次一个基线）

### 内存管理

**估算**:
- 单次扫描内存占用: ~50MB
- 最大并发任务数: 受 GOMAXPROCS 限制
- 预期总内存: < 200MB

---

## 任务生命周期

### 按需任务生命周期

```
1. Created (创建)
   ↓
   Server 下发任务
   ↓
2. Received (接收)
   ↓
   pluginClient.ReceiveTask()
   ↓
3. Queued (排队)
   ↓
   等待 Goroutine 调度
   ↓
4. Running (执行中)
   ↓
   check.Analysis(taskData)
   ├─ 加载配置
   ├─ 执行检查
   └─ 格式化结果
   ↓
5. Reporting (上报中)
   ↓
   SendServer(result, token)
   TaskStatusSendServer(status, token)
   ↓
6. Completed (完成)
   ↓
   Goroutine 结束
```

### 定时任务生命周期

```
1. Scheduled (调度中)
   ↓
   等待 Ticker 触发
   ↓
2. Triggered (触发)
   ↓
   <-dailyTicker.C
   ↓
3. Delayed (延迟中)
   ↓
   随机延迟 0-6 小时
   ↓
4. Running (执行中)
   ↓
   ├─ 检测操作系统
   ├─ 选择默认基线
   ├─ 执行扫描
   └─ 上报结果
   ↓
5. Completed (完成)
   ↓
6. Re-scheduled (重新调度)
   ↓
   dailyTicker.Reset(24 * time.Hour)
   ↓
   回到 1
```

### 任务状态

| 状态 | 说明 | 上报到 Server |
|------|------|--------------|
| Queued | 任务已接收，等待执行 | ❌ |
| Running | 正在执行检查 | ❌ |
| Success | 执行成功 | ✅ (DataType: 8010, status="succeed") |
| Failed | 执行失败 | ✅ (DataType: 8010, status="failed") |

### 错误处理

**任务接收错误**:

```go
pluginsTask, err := pluginClient.ReceiveTask()
if err != nil {
    infra.Loger.Println("getTask error:", err.Error())
    break  // 退出任务接收循环
}
```

**任务执行错误**:

```go
retBaselineInfo, analysisErr := check.Analysis(pluginsTask.Data)

if analysisErr != nil {
    // 上报失败状态
    TaskStatusSendServer(TaskStatusFailed, pluginsTask.Token, analysisErr.Error())
} else {
    // 上报成功状态
    TaskStatusSendServer(TaskStatusSuccess, pluginsTask.Token, "")
}
```

**结果上报错误**:

```go
err = SendServer(retBaselineInfo, pluginsTask.Token)
if err != nil {
    infra.Loger.Println("sendServer error:", err)
    // 记录日志，但不中断流程
}
```

---

## 调优建议

### 1. 调整 CPU 限制

**场景**: 高性能服务器，希望加快扫描速度

```go
// 修改 main.go:26
runtime.GOMAXPROCS(8)  // 增加到 8 核

// 重新编译
./build.sh
```

**建议**:
- 生产环境: 4 核（默认）
- 测试环境: 8-16 核
- 低配机器: 2 核

### 2. 修改定时扫描时间

**场景**: 业务高峰期在夜间，需要调整扫描时间

```go
// 修改 main.go:108
// 原始: 0:00-6:00 随机
time.Date(..., rand.Intn(6), ...)

// 修改为: 6:00-12:00 随机
time.Date(..., 6 + rand.Intn(6), ...)

// 修改为: 固定 2:00 执行
time.Date(..., 2, 0, 0, ...)
```

### 3. 禁用定时扫描

**场景**: 只使用按需扫描

```go
// 注释掉 main.go:106-152 的定时调度代码
/*
dailyTicker := time.NewTicker(...)
for {
    select {
    case <-dailyTicker.C:
        // ...
    }
}
*/
```

### 4. 添加多个默认基线

**场景**: 同时执行多个基线

```go
// 修改 main.go:19-21
var (
    CentosDefaultList = []int{1200, 5000}  // CentOS基线 + 弱密码基线
    DebianDefaultList = []int{1300, 5000}
    UbuntuDefaultList = []int{1400, 5000}
)
```

### 5. 优化检查项

**场景**: 减少单次扫描时间

**方法**:
- 移除非必要检查项
- 禁用耗时命令（如 `find / ...`）
- 合并相关检查

**示例**:

```yaml
# 优化前: 扫描整个文件系统
- type: command_check
  param: ["find / -type f -perm -002"]

# 优化后: 只扫描关键目录
- type: command_check
  param: ["find /etc /var /usr/bin -type f -perm -002"]
```

### 6. 监控扫描性能

**添加性能日志**:

```go
// 在 analysis.go 中添加
start := time.Now()
retBaselineInfo, err := AnalysisBaseline(taskData)
duration := time.Since(start)

infra.Loger.Printf("Baseline %d completed in %v", baselineId, duration)
```

**分析日志**:

```bash
grep "completed in" baseline.log | awk '{print $NF}' | sort -n
# 输出: 各次扫描耗时，便于优化
```

---

## 常见问题

### Q: 如何立即触发定时扫描？

A: 定时扫描由 Ticker 控制，无法手动触发。建议使用按需扫描代替：

```json
{
    "baseline_id": 1200,
    "check_id_list": []
}
```

### Q: 定时扫描和按需扫描会冲突吗？

A: 不会。两者在不同 Goroutine 中运行，互不影响。按需扫描异步执行，不会阻塞定时扫描。

### Q: 如何查看当前执行的任务？

A: 查看日志文件：

```bash
tail -f baseline.log | grep "sendServer"
```

### Q: 扫描时间过长怎么办？

A:
1. 检查是否有耗时命令（如 `find /`）
2. 减少检查项数量
3. 增加 GOMAXPROCS 值
4. 优化 YAML 配置（使用 filter、flag）

### Q: 如何确保扫描不影响业务？

A:
1. 使用默认 GOMAXPROCS(4) 限制 CPU
2. 定时扫描在低峰期（0:00-6:00）执行
3. 避免频繁执行按需扫描
4. 监控系统负载，必要时调整配置

---

## 下一步阅读

- **了解数据协议** → [05-数据协议.md](./05-数据协议.md)
- **学习配置编写** → [03-基线配置.md](./03-基线配置.md)
- **深入规则引擎** → [02-规则引擎.md](./02-规则引擎.md)
