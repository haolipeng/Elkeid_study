# Elkeid Baseline 插件 - 规则引擎设计

## 目录
- [规则引擎概述](#规则引擎概述)
- [条件逻辑](#条件逻辑)
- [运算符系统](#运算符系统)
- [规则类型详解](#规则类型详解)
- [过滤器机制](#过滤器机制)
- [结果匹配流程](#结果匹配流程)
- [扩展开发指南](#扩展开发指南)

---

## 规则引擎概述

规则引擎是 Baseline 插件的核心，负责解析和执行 YAML 配置文件中定义的检查规则。

### 设计目标

1. **灵活性**: 支持多种检查类型和复杂条件
2. **可扩展性**: 易于添加新的规则类型和运算符
3. **类型安全**: 自动处理类型转换和验证
4. **错误处理**: 清晰的错误码和错误信息

### 核心组件

```
┌─────────────────────────────────────────────────────────┐
│                   Rule Engine                            │
│                                                          │
│  ┌────────────────────────────────────────────────┐    │
│  │  AnalysisRule (规则分析入口)                    │    │
│  │  - 解析 condition (all/any/none)               │    │
│  │  - 遍历 rules 数组                             │    │
│  │  - 根据条件返回最终结果                         │    │
│  └──────────────────┬─────────────────────────────┘    │
│                     │                                    │
│                     ▼                                    │
│  ┌────────────────────────────────────────────────┐    │
│  │  CheckRule (规则分发器)                         │    │
│  │  - 根据 rule.type 调用对应检查函数              │    │
│  │  - 处理 require 前置条件                        │    │
│  └──────────────────┬─────────────────────────────┘    │
│                     │                                    │
│        ┌────────────┴────────────┐                      │
│        ▼                         ▼                      │
│  ┌──────────┐            ┌────────────────┐            │
│  │  Rules   │            │ Result Matcher │            │
│  │ Executor │            │  (结果匹配器)   │            │
│  └──────────┘            └────────────────┘            │
│  - CommandCheck          - 类型转换                     │
│  - FileLineCheck         - 运算符解析                   │
│  - FilePermission        - 过滤器应用                   │
│  - FileUserGroup         - 逻辑运算                     │
│  - IfFileExist                                          │
│  - FileMd5Check                                         │
│  - FuncCheck                                            │
└─────────────────────────────────────────────────────────┘
```

---

## 条件逻辑

### Condition 类型

规则引擎支持三种条件逻辑，通过 `condition` 字段指定：

| Condition | 逻辑 | 说明 | 使用场景 |
|-----------|------|------|----------|
| `all` | AND | 所有规则必须通过 | 多个条件必须同时满足 |
| `any` | OR | 任意规则通过即可 | 多个条件满足一个即可 |
| `none` | NOR | 所有规则必须不通过 | 确保某些配置不存在 |

### 实现逻辑

**源码** (`rule_engine.go:307-337`):

```go
func AnalysisRule(check BaselineCheck) (ifPass bool, err error) {
    condition := check.Condition
    if condition == "" {
        condition = "all"  // 默认为 all
    }

    for _, rule := range check.Rules {
        // 执行单条规则
        ifCheck, err := CheckRule(rule)
        if err != nil {
            return false, err
        }

        // 根据条件类型决定返回时机
        if ifCheck {  // 规则通过
            if condition == "any" {
                return true, err  // any: 一个通过即返回 true
            } else if condition == "none" {
                return false, err // none: 一个通过即返回 false
            }
        } else {  // 规则失败
            if condition == "all" {
                return false, err  // all: 一个失败即返回 false
            }
        }
    }

    // 所有规则遍历完毕
    if condition == "any" {
        return false, err  // any: 全部失败返回 false
    } else {
        return true, err   // all/none: 全部通过返回 true
    }
}
```

### 配置示例

#### ALL 条件示例

```yaml
# 密码策略必须同时满足长度和有效期要求
check:
  condition: all
  rules:
    - type: file_line_check
      param: ["/etc/login.defs"]
      filter: 'PASS_MIN_LEN\s+(\d+)'
      result: '$(>=)8'

    - type: file_line_check
      param: ["/etc/login.defs"]
      filter: 'PASS_MAX_DAYS\s+(\d+)'
      result: '$(<=)90'
```

#### ANY 条件示例

```yaml
# SSH配置可以使用密钥认证或禁用root登录（满足一个即可）
check:
  condition: any
  rules:
    - type: file_line_check
      param: ["/etc/ssh/sshd_config", "PubkeyAuthentication"]
      result: ".*yes$"

    - type: file_line_check
      param: ["/etc/ssh/sshd_config", "PermitRootLogin"]
      result: "$(not).*yes$"
```

#### NONE 条件示例

```yaml
# 确保没有启用不安全的配置
check:
  condition: none
  rules:
    - type: file_line_check
      param: ["/etc/ssh/sshd_config", "PermitEmptyPasswords"]
      result: ".*yes$"

    - type: file_line_check
      param: ["/etc/ssh/sshd_config", "Protocol"]
      result: ".*1.*"
```

---

## 运算符系统

规则引擎支持多种运算符，用于结果匹配和条件判断。

### 关系运算符

用于数值比较，语法: `$(<operator>)value`

| 运算符 | 语法 | 说明 | 示例 |
|--------|------|------|------|
| 小于 | `$(<)N` | 实际值 < N | `$(<)90` |
| 小于等于 | `$(<=)N` | 实际值 <= N | `$(<=)90` |
| 大于 | `$(>)N` | 实际值 > N | `$(>)7` |
| 大于等于 | `$(>=)N` | 实际值 >= N | `$(>=)8` |

**实现** (`rule_engine.go:72-122`):

```go
func DealMathCompute(funcRes interface{}, ruleRes string) (ifPass bool, err error) {
    // 提取运算符: "$(>=)8" → operator = ">=", rule = "8"
    reg := "\\$\\((.+)\\)"
    operator, ifMatch, _ := StringMatch(ruleRes, reg)

    if ifMatch {
        // 提取数值部分
        rule := ruleRes[len(operator)+3:]  // 跳过 $() 和运算符
        ruleInt, _ := strconv.Atoi(rule)

        // 转换函数结果为 int
        var funcInt int
        switch funcRes.(type) {
        case int:
            funcInt = funcRes.(int)
        case string:
            funcInt, err = strconv.Atoi(funcRes.(string))
            if err != nil {
                return false, errors.New("need get num, but get string")
            }
        }

        // 执行比较
        switch operator {
        case "<":
            ifPass = funcInt < ruleInt
        case "<=":
            ifPass = funcInt <= ruleInt
        case ">":
            ifPass = funcInt > ruleInt
        case ">=":
            ifPass = funcInt >= ruleInt
        }
    }

    return ifPass, err
}
```

**使用示例**:

```yaml
# 密码最小长度 >= 8
rules:
  - type: file_line_check
    param: ["/etc/login.defs"]
    filter: 'PASS_MIN_LEN\s+(\d+)'
    result: '$(>=)8'

# 文件权限 < 600
rules:
  - type: file_permission
    param: ["/etc/shadow", "600"]
    result: true
```

### 逻辑运算符

#### NOT 运算符

语法: `$(not)pattern`

**功能**: 对匹配结果取反

**实现** (`rule_engine.go:204-209`):

```go
reverse := false
if strings.HasPrefix(rule, "$(not)") {
    reverse = true
    rule = rule[len("$(not)"):]  // 移除前缀
}

// ... 执行匹配 ...

if reverse {
    ifPass = !ifPass  // 结果取反
}
```

**使用示例**:

```yaml
# root 用户不应使用 nologin shell
rules:
  - type: file_line_check
    param: ["/etc/passwd"]
    filter: "^root:"
    result: "$(not).*nologin$"

# SSH 禁用密码认证
rules:
  - type: file_line_check
    param: ["/etc/ssh/sshd_config", "PasswordAuthentication"]
    result: "$(not).*yes$"
```

#### AND 运算符

语法: `$(&&)condition1&&condition2`

**功能**: 多个子条件必须同时满足

**实现** (`rule_engine.go:195-241`):

```go
// 拆分子规则
var ruleArray []string
if strings.Contains(ruleString, "$(&&)") {
    ruleArray = strings.Split(ruleString, "$(&&)")
} else {
    ruleArray = append(ruleArray, ruleString)
}

// 遍历子规则
for _, rule := range ruleArray {
    // 处理 $(not) 前缀
    reverse := false
    if strings.HasPrefix(rule, "$(not)") {
        reverse = true
        rule = rule[len("$(not)"):]
    }

    // 匹配子规则
    if strings.HasPrefix(rule, "$(") {
        ifPass, err = DealMathCompute(funcRes, rule)
    } else {
        _, ifPass, err = StringMatch(funcRes.(string), rule)
    }

    // 取反处理
    if reverse {
        ifPass = !ifPass
    }

    // 任意子规则失败，整体失败
    if ifPass == false {
        return false, err
    }
}
```

**使用示例**:

```yaml
# 密码必须同时满足长度和有效期
rules:
  - type: file_line_check
    param: ["/etc/login.defs"]
    result: '$(&&)PASS_MIN_LEN\s+(\d+)$(>=)8&&PASS_MAX_DAYS\s+(\d+)$(<=)90'
```

### 字符串匹配

#### 精确匹配

```yaml
# 检查文件内容是否完全匹配
rules:
  - type: command_check
    param: ["cat /etc/hostname"]
    result: "prod-server-01"
```

#### 正则表达式匹配

```yaml
# 检查是否匹配正则模式
rules:
  - type: file_line_check
    param: ["/etc/passwd"]
    result: "^root:.*:/bin/bash$"
```

**实现** (`rule_engine.go:54-69`):

```go
func StringMatch(str string, reg string) (subStr string, ifMatch bool, err error) {
    // 编译正则表达式
    regCom, err := regexp.Compile(reg)
    if err != nil {
        return "", false, err
    }

    // 执行匹配
    matchList := regCom.FindStringSubmatch(str)

    if len(matchList) == 0 {
        return "", false, err  // 不匹配
    } else if len(matchList) == 1 {
        return "", true, err   // 匹配但无分组
    } else {
        return matchList[1], true, err  // 返回第一个分组
    }
}
```

---

## 规则类型详解

### 1. command_check - 命令检查

**功能**: 执行Shell命令并检查输出

**参数**:
- `param[0]`: 命令字符串
- `param[1]`: (可选) 特殊参数
  - `ignore_exit`: 忽略命令执行错误

**返回**: 命令输出字符串

**实现** (`rules.go:24-49`):

```go
func CommandCheck(param []string) (result interface{}, err error) {
    command := param[0]
    argArray := strings.Split(command, " ")

    // 执行命令
    cmd := exec.Command(argArray[0], argArray[1:]...)
    buf, err := cmd.Output()

    if err != nil {
        // 特殊处理: ignore_exit
        if len(param) == 2 && param[1] == "ignore_exit" {
            return true, nil
        }
        return false, nil
    }

    return string(buf), err
}
```

**配置示例**:

```yaml
# 检查 umask 值
- type: command_check
  param: ["umask"]
  result: '$(>=)0022'

# 检查 SELinux 状态
- type: command_check
  param: ["getenforce"]
  result: "Enforcing"

# 检查命令是否存在（忽略错误）
- type: command_check
  param: ["which firewalld", "ignore_exit"]
  result: true
```

### 2. file_line_check - 文件内容检查

**功能**: 逐行读取文件并匹配内容

**参数**:
- `param[0]`: 文件绝对路径
- `param[1]`: (可选) 行标识符（只匹配包含此字符串的行）
- `param[2]`: (可选) 注释符（默认 `#`）

**特性**:
- 自动跳过注释行
- 支持 `filter` 字段提取子串
- 逐行匹配，任意一行通过即返回 true

**实现** (`rules.go:75-131`):

```go
func FileLineCheck(ruleStruct RuleStruct, resultMatch ResultMatchFunc) (result bool, err error) {
    // 解析参数
    filePath := ruleStruct.Param[0]
    flag := ""  // 行标识符
    note := "#" // 注释符

    if len(ruleStruct.Param) >= 2 {
        flag = ruleStruct.Param[1]
    }
    if len(ruleStruct.Param) >= 3 {
        note = ruleStruct.Param[2]
    }

    // 打开文件
    file, err := os.Open(filePath)
    if err != nil {
        if strings.Contains(err.Error(), "no such") {
            return false, nil  // 文件不存在不报错
        }
        return false, err
    }

    // 逐行扫描
    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
        line := strings.TrimSpace(scanner.Text())

        // 跳过注释行
        if len(line) > len(note) && note == line[:len(note)] {
            continue
        }

        // 只匹配包含 flag 的行
        if flag != "" && !strings.Contains(line, flag) {
            continue
        }

        // 执行结果匹配
        ifPass, _ := resultMatch(ruleStruct, scanner.Text())
        if ifPass {
            return true, nil  // 任意一行通过即返回
        }
    }

    return false, nil
}
```

**配置示例**:

```yaml
# 示例1: 检查密码有效期
- type: file_line_check
  param: ["/etc/login.defs"]
  filter: 'PASS_MAX_DAYS\s+(\d+)'
  result: '$(<=)90'

# 示例2: 检查SSH配置（只匹配包含 PermitRootLogin 的行）
- type: file_line_check
  param: ["/etc/ssh/sshd_config", "PermitRootLogin"]
  result: "$(not).*yes$"

# 示例3: 检查 crontab（指定注释符）
- type: file_line_check
  param: ["/etc/crontab", "0 0", "#"]
  result: ".*backup.*"

# 示例4: 检查root用户配置
- type: file_line_check
  param: ["/etc/passwd"]
  filter: "^root:.*:([^:]+)$"
  result: "$(not)/sbin/nologin"
```

### 3. file_permission - 文件权限检查

**功能**: 检查文件权限是否符合要求

**参数**:
- `param[0]`: 文件绝对路径
- `param[1]`: 期望的最大权限（八进制字符串）

**逻辑**: 实际权限 < 期望权限 → 通过

**实现** (`rules.go:136-159`):

```go
func FilePermission(param []string) (result bool, err error) {
    filePath := param[0]
    fileNeedMode, _ := strconv.Atoi(param[1])

    // 获取文件信息
    fileInfo, err := os.Stat(filePath)
    if err != nil {
        if strings.Contains(err.Error(), "no such file") {
            return true, nil  // 文件不存在视为通过
        }
        return
    }

    // 获取实际权限（转换为八进制数字）
    fileRealMode, _ := strconv.Atoi(
        strconv.FormatInt(int64(fileInfo.Mode()), 8))

    // 验证: 实际权限应小于期望权限
    return fileRealMode < fileNeedMode, err
}
```

**权限说明**:

| 权限值 | 含义 | 说明 |
|--------|------|------|
| 600 | rw------- | 仅所有者可读写 |
| 640 | rw-r----- | 所有者读写，组可读 |
| 644 | rw-r--r-- | 所有者读写，其他只读 |
| 700 | rwx------ | 仅所有者可读写执行 |
| 755 | rwxr-xr-x | 所有者全权限，其他可读执行 |

**配置示例**:

```yaml
# /etc/shadow 权限应严格限制
- type: file_permission
  param: ["/etc/shadow", "600"]
  result: true

# /etc/passwd 权限不应超过 644
- type: file_permission
  param: ["/etc/passwd", "644"]
  result: true

# SSH 私钥文件权限检查
- type: file_permission
  param: ["/root/.ssh/id_rsa", "600"]
  result: true
```

### 4. file_user_group - 文件所有者检查

**功能**: 检查文件的所有者和组

**参数**:
- `param[0]`: 文件绝对路径
- `param[1]`: 期望的 UID:GID（如 `0:0` 表示 root:root）

**返回**: 实际 UID:GID == 期望 UID:GID

**实现** (`rules.go:164-188`):

```go
func FileUserGroup(param []string) (result bool, err error) {
    filePath := param[0]

    // 解析期望的 UID:GID
    res := strings.Split(param[1], ":")
    userNeedId := res[0]
    groupNeedId := res[1]

    // 获取文件信息
    fileInfo, err := os.Stat(filePath)
    if err != nil {
        return
    }

    // 获取实际的 UID 和 GID
    stat := fileInfo.Sys().(*syscall.Stat_t)
    userRealId := strconv.FormatUint(uint64(stat.Uid), 10)
    groupRealId := strconv.FormatUint(uint64(stat.Gid), 10)

    // 验证
    return userNeedId == userRealId && groupNeedId == groupRealId, err
}
```

**配置示例**:

```yaml
# /etc/passwd 应归 root:root 所有
- type: file_user_group
  param: ["/etc/passwd", "0:0"]
  result: true

# /etc/shadow 应归 root:root 所有
- type: file_user_group
  param: ["/etc/shadow", "0:0"]
  result: true

# 检查特定用户的文件
- type: file_user_group
  param: ["/home/user/config", "1000:1000"]
  result: true
```

### 5. if_file_exist - 文件存在性检查

**功能**: 检查文件是否存在

**参数**:
- `param[0]`: 文件绝对路径

**返回**: bool (存在=true, 不存在=false)

**实现** (`rules.go:53-67`):

```go
func IfFileExist(param []string) (result interface{}, err error) {
    filePath := param[0]

    _, err = os.Stat(filePath)
    if err != nil {
        return false, nil  // 文件不存在
    } else {
        return true, nil   // 文件存在
    }
}
```

**配置示例**:

```yaml
# 确保安全配置文件存在
- type: if_file_exist
  param: ["/etc/security/limits.conf"]
  result: true

# 确保不存在不安全的配置
- type: if_file_exist
  param: ["/etc/hosts.equiv"]
  result: false

# 检查防火墙配置
- type: if_file_exist
  param: ["/etc/firewalld/firewalld.conf"]
  result: true
```

### 6. file_md5_check - 文件完整性检查

**功能**: 计算文件MD5哈希值

**参数**:
- `param[0]`: 文件绝对路径
- `param[1]`: 期望的MD5值

**返回**: 实际MD5 == 期望MD5

**实现** (`rules.go:193-216`):

```go
func FileMd5Check(param []string) (result bool, err error) {
    filePath := param[0]
    fileMd5 := param[1]

    // 读取文件内容
    file, err := os.Open(filePath)
    if err != nil {
        return false, fmt.Errorf("file_md5_check: no file find %s", filePath)
    }
    fileContentByte, err := ioutil.ReadAll(file)
    if err != nil {
        return false, err
    }

    // 计算MD5
    hash := md5.New()
    hash.Write(fileContentByte)
    actualMd5 := hex.EncodeToString(hash.Sum(nil))

    // 验证
    return fileMd5 == actualMd5, nil
}
```

**配置示例**:

```yaml
# 检查关键配置文件是否被篡改
- type: file_md5_check
  param:
    - "/etc/sudoers"
    - "d41d8cd98f00b204e9800998ecf8427e"
  result: true

# 检查系统二进制文件完整性
- type: file_md5_check
  param:
    - "/usr/bin/sudo"
    - "a1b2c3d4e5f6..."
  result: true
```

### 7. func_check - 自定义函数检查

**功能**: 调用预定义的自定义检查函数

**参数**:
- `param[0]`: 函数名称

**内置函数**:

#### IfDuplicateUser - 检查重复用户名

**实现** (`rules.go:235-253`):

```go
func IfDuplicateUser() bool {
    file, _ := os.Open("/etc/passwd")
    scanner := bufio.NewScanner(file)
    userSet := make(map[string]string, 0)

    for scanner.Scan() {
        // 提取用户名（第一个字段）
        index := strings.Index(scanner.Text(), ":")
        if index != -1 {
            username := scanner.Text()[:index]

            // 检查是否重复
            if _, ok := userSet[username]; ok {
                return false  // 发现重复
            } else {
                userSet[username] = ""
            }
        }
    }

    return true  // 无重复
}
```

#### IfAllowSshPasswd - 检查SSH密码认证

**实现** (`rules.go:256-273`):

```go
func IfAllowSshPasswd() bool {
    file, _ := os.Open("/etc/ssh/sshd_config")
    scanner := bufio.NewScanner(file)

    for scanner.Scan() {
        line := strings.TrimSpace(scanner.Text())

        // 跳过注释行
        if len(line) > 2 && "#" == line[:1] {
            continue
        }

        // 检查 PasswordAuthentication 配置
        if strings.Contains(line, "PasswordAuthentication") {
            if strings.Contains(line, "yes") {
                return true
            }
        }
    }

    return false
}
```

**配置示例**:

```yaml
# 检查是否存在重复用户名
- type: func_check
  param: ["Ensure no duplicate user names exist"]
  result: true
```

**扩展自定义函数**:

1. 在 `rules.go` 中实现新函数:

```go
func CustomCheckFunction() bool {
    // 实现检查逻辑
    return true
}
```

2. 在 `FuncCheck` 中注册:

```go
func FuncCheck(param []string) (result interface{}, err error) {
    var funcRes bool
    switch param[0] {
    case "Ensure no duplicate user names exist":
        funcRes = IfDuplicateUser()
    case "My Custom Check":  // 新增
        funcRes = CustomCheckFunction()
    }
    return funcRes, nil
}
```

3. 在 YAML 中使用:

```yaml
- type: func_check
  param: ["My Custom Check"]
  result: true
```

---

## 过滤器机制

### Filter 字段

`filter` 字段用于从文件内容中提取特定子串，常与 `file_line_check` 配合使用。

**原理**:

```
原始内容: "PASS_MAX_DAYS    90"
          ↓
应用 filter: 'PASS_MAX_DAYS\s+(\d+)'
          ↓
提取分组: "90"
          ↓
应用 result: '$(<=)90'
          ↓
结果: true
```

### 实现逻辑

**源码** (`rule_engine.go:182-192`):

```go
// Filter 规则
ruleFilter := ruleStruct.Filter
subStr := ""

if ruleFilter != "" && funcType == reflect.String {
    // 应用正则过滤器
    ifMatch := false
    subStr, ifMatch, err = StringMatch(funcRes.(string), ruleFilter)

    if err != nil || !ifMatch {
        errStr := fmt.Sprintf("rule filter error: funcRes:%s, rule:%s",
            funcRes.(string), ruleFilter)
        return ifPass, errors.New(errStr)
    }
}

// 后续使用 subStr 而非原始 funcRes
if subStr != "" {
    ifPass, err = DealMathCompute(subStr, rule)
} else {
    ifPass, err = DealMathCompute(funcRes, rule)
}
```

### 使用场景

#### 场景1: 提取配置参数值

```yaml
# 从 "PASS_MAX_DAYS    90" 中提取 90
filter: 'PASS_MAX_DAYS\s+(\d+)'
result: '$(<=)90'
```

#### 场景2: 提取字段

```yaml
# 从 "root:x:0:0:root:/root:/bin/bash" 中提取 shell
filter: '^root:.*:([^:]+)$'
result: '$(not)/sbin/nologin'
```

#### 场景3: 多字段提取

```yaml
# 从 "PermitRootLogin no" 中提取 no
filter: 'PermitRootLogin\s+(\w+)'
result: 'no'
```

### 完整示例

```yaml
check_id: 1
title: "检查密码有效期"
check:
  rules:
    - type: file_line_check
      param: ["/etc/login.defs"]
      filter: '\s*PASS_MAX_DAYS\s+(\d+)'  # 提取数字
      result: '$(<=)90'                    # 验证 <= 90
```

**执行流程**:

1. 读取 `/etc/login.defs` 文件
2. 逐行匹配正则 `\s*PASS_MAX_DAYS\s+(\d+)`
3. 提取分组1的值（假设为 "180"）
4. 应用运算符: 180 <= 90 → false
5. 返回检查失败

---

## 结果匹配流程

### 类型转换

规则引擎自动处理类型转换，支持以下类型：

| 规则类型 | 函数返回类型 | 自动转换 |
|---------|-------------|---------|
| bool | bool | 无需转换 |
| int | string/int | string→int |
| string | int/string | int→string |

**实现** (`rule_engine.go:133-180`):

```go
func ResultMatch(ruleStruct RuleStruct, funcRes interface{}) (ifPass bool, err error) {
    ruleRes := ruleStruct.Result
    if ruleRes == nil {
        ruleRes = true  // 默认期望 true
    }

    funcType := reflect.TypeOf(funcRes).Kind()

    switch ruleRes.(type) {
    case bool:
        // rule 是 bool，func 必须也是 bool
        if funcType == reflect.Bool {
            return ruleRes == funcRes, err
        } else {
            return false, errors.New("rule is bool, but get other type")
        }

    case int:
        // rule 是 int，func 可以是 int 或 string
        if funcType == reflect.String {
            funcInt, err := strconv.Atoi(funcRes.(string))
            if err == nil {
                funcRes = funcInt  // 转换成功
            } else {
                return false, errors.New("rule is int, but get string")
            }
        }
        return ruleRes == funcRes, err

    case string:
        // rule 是 string，func 可以是 int、string、bool
        if funcType == reflect.Int {
            funcRes = strconv.Itoa(funcRes.(int))  // int→string
        } else if funcType == reflect.Bool {
            return funcRes.(bool), err  // bool 直接返回
        }

        // ... 应用 filter、运算符等 ...
    }

    return ifPass, err
}
```

### 匹配流程

```
┌─────────────────────────────────────────────────────┐
│             Result Match Process                    │
│                                                     │
│  1. 类型检查                                         │
│     ├─ rule.result 类型                             │
│     └─ func 返回值类型                              │
│                                                     │
│  2. 类型转换                                         │
│     ├─ string → int                                 │
│     ├─ int → string                                 │
│     └─ bool (无需转换)                              │
│                                                     │
│  3. 应用 Filter (如果存在)                          │
│     └─ 正则提取子串                                 │
│                                                     │
│  4. 处理逻辑运算符                                   │
│     ├─ 拆分 $(&&) 子规则                            │
│     └─ 遍历子规则                                   │
│                                                     │
│  5. 处理 $(not) 前缀                                │
│     └─ reverse = true                               │
│                                                     │
│  6. 应用运算符                                       │
│     ├─ 关系运算 $(>=), $(<=), ...                   │
│     └─ 正则匹配                                     │
│                                                     │
│  7. 结果取反 (如果 reverse)                         │
│     └─ ifPass = !ifPass                            │
│                                                     │
│  8. 返回最终结果                                     │
│     └─ true / false                                 │
└─────────────────────────────────────────────────────┘
```

---

## 扩展开发指南

### 添加新规则类型

**步骤**:

1. **在 `rules.go` 中实现规则函数**

```go
// 示例: 检查网络连通性
func NetworkCheck(param []string) (result interface{}, err error) {
    host := param[0]
    timeout := 5 * time.Second

    conn, err := net.DialTimeout("tcp", host, timeout)
    if err != nil {
        return false, nil
    }
    defer conn.Close()

    return true, nil
}
```

2. **在 `rule_engine.go` 的 `CheckRule` 中添加分支**

```go
func CheckRule(ruleStruct RuleStruct) (ifPass bool, err error) {
    var funcRes interface{}

    switch ruleStruct.Type {
    // ... 现有规则 ...

    case "network_check":  // 新增
        funcRes, err = NetworkCheck(ruleStruct.Param)

    default:
        return false, errors.New("unknown rule type")
    }

    // ... 后续处理 ...
}
```

3. **在 YAML 配置中使用**

```yaml
rules:
  - type: network_check
    param: ["192.168.1.1:22"]
    result: true
```

### 添加新运算符

**步骤**:

1. **在 `rule_engine.go` 中添加运算符逻辑**

```go
// 示例: 添加不等于运算符 $(!=)
func DealMathCompute(funcRes interface{}, ruleRes string) (ifPass bool, err error) {
    reg := "\\$\\((.+)\\)"
    operator, ifMatch, _ := StringMatch(ruleRes, reg)

    if ifMatch {
        rule := ruleRes[len(operator)+3:]
        ruleInt, _ := strconv.Atoi(rule)
        funcInt := funcRes.(int)

        switch operator {
        // ... 现有运算符 ...

        case "!=":  // 新增
            ifPass = funcInt != ruleInt

        }
    }

    return ifPass, err
}
```

2. **在 YAML 中使用**

```yaml
rules:
  - type: command_check
    param: ["id -u"]
    result: '$(!=)0'  # 确保不是 root 用户
```

### 添加自定义函数

请参考 [规则类型详解 - func_check](#7-func_check---自定义函数检查) 章节。

---

## 最佳实践

### 1. 规则编写建议

**DO**:
- 使用 `filter` 提取精确字段
- 合理使用 `condition` (all/any/none)
- 为复杂检查添加注释

**DON'T**:
- 不要在单个规则中包含过多逻辑
- 避免过于复杂的正则表达式
- 不要忽略文件不存在的情况

### 2. 性能优化

- 避免频繁执行耗时命令
- 合理使用 `flag` 参数减少行匹配
- 优先使用内置规则而非 `command_check`

### 3. 错误处理

- 检查文件存在性再读取内容
- 使用 `ignore_exit` 处理可选命令
- 提供清晰的错误信息

---

## 下一步阅读

- **学习配置编写** → [03-基线配置.md](./03-基线配置.md)
- **理解调度机制** → [04-任务调度.md](./04-任务调度.md)
- **了解数据协议** → [05-数据协议.md](./05-数据协议.md)
