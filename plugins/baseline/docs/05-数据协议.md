# Elkeid Baseline 插件 - 数据协议设计

## 目录
- [协议概述](#协议概述)
- [任务接收协议](#任务接收协议)
- [结果上报协议](#结果上报协议)
- [状态上报协议](#状态上报协议)
- [错误处理](#错误处理)
- [日志规范](#日志规范)

---

## 协议概述

Baseline 插件通过 Elkeid Plugin SDK 与 Elkeid Agent/Server 通信，使用 JSON 格式交换数据。

### 通信模型

```
┌─────────────┐                          ┌─────────────┐
│   Elkeid    │                          │  Baseline   │
│   Server    │                          │   Plugin    │
└──────┬──────┘                          └──────┬──────┘
       │                                        │
       │  1. Send Task (JSON)                  │
       │───────────────────────────────────────▶│
       │                                        │
       │                                        │  2. Process
       │                                        │  - Load config
       │                                        │  - Execute checks
       │                                        │  - Format result
       │                                        │
       │  3. Send Result (DataType: 8000)      │
       │◀───────────────────────────────────────│
       │                                        │
       │  4. Send Status (DataType: 8010)      │
       │◀───────────────────────────────────────│
       │                                        │
```

### DataType 定义

| DataType | 名称 | 方向 | 说明 |
|----------|------|------|------|
| - | Task Data | Server → Plugin | 任务数据（JSON字符串） |
| 8000 | Baseline Result | Plugin → Server | 基线检查结果 |
| 8010 | Task Status | Plugin → Server | 任务执行状态 |

**源码定义** (`main.go:15-16`):

```go
var (
    BaseLineDataType           = 8000  // 结果数据类型
    BaseLineTaskStatusDataType = 8010  // 状态数据类型
)
```

---

## 任务接收协议

### 接口定义

**Plugin SDK 接口**:

```go
func (c *Client) ReceiveTask() (*Task, error)

type Task struct {
    Token string      // 任务令牌（用于关联结果）
    Data  interface{} // 任务数据（JSON 字符串或整数）
}
```

### 数据格式

#### 按需扫描任务

```json
{
    "baseline_id": 1200,
    "check_id_list": [1, 2, 3, 10, 20]
}
```

**字段说明**:

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| baseline_id | int | ✅ | 基线ID（1200/1300/1400/5000等） |
| check_id_list | []int | ✅ | 检查项ID列表，空数组表示全部 |

#### 定时扫描任务

定时扫描不通过任务接收接口，而是直接传入 baseline_id（整数）：

```go
// main.go:135
retBaselineInfo, analysisErr := check.Analysis(baselineId)
// baselineId 是 int 类型，不是 JSON 字符串
```

### 任务解析

**源码** (`analysis.go:127-140`):

```go
func Analysis(data interface{}) (retBaselineInfo RetBaselineInfo, err error) {
    var taskData TaskData

    // 类型判断
    switch data.(type) {
    case int:
        // 定时扫描: 直接传入 baseline_id
        taskData.BaselineId = data.(int)

    case string:
        // 按需扫描: JSON 字符串
        err = json.Unmarshal([]byte(data.(string)), &taskData)
        if err != nil {
            retBaselineInfo.Status = BaselineStatusError
            retBaselineInfo.Msg = err.Error()
            return retBaselineInfo, err
        }
    }

    // 执行分析
    retBaselineInfo, err = AnalysisBaseline(taskData)
    return retBaselineInfo, err
}
```

### TaskData 结构体

**定义** (`analysis.go:34-37`):

```go
type TaskData struct {
    BaselineId  int   `json:"baseline_id"`   // 基线ID
    CheckIdList []int `json:"check_id_list"` // 检查项ID列表
}
```

### 示例

#### 示例1: 执行完整基线

```json
{
    "baseline_id": 1200,
    "check_id_list": []
}
```

**效果**: 执行 CentOS 基线的所有检查项（~120项）

#### 示例2: 执行指定检查项

```json
{
    "baseline_id": 1200,
    "check_id_list": [1, 2, 3]
}
```

**效果**: 只执行 check_id 为 1, 2, 3 的检查项

#### 示例3: 跨基线检查

```json
{
    "baseline_id": 5000,
    "check_id_list": []
}
```

**效果**: 执行弱密码基线（跨平台）

---

## 结果上报协议

### DataType: 8000

用于上报基线检查的详细结果。

### 数据结构

**RetBaselineInfo** (`analysis.go:11-17`):

```go
type RetBaselineInfo struct {
    BaselineId      int            `json:"baseline_id"`      // 基线ID
    BaselineVersion string         `json:"baseline_version"` // 基线版本
    Status          string         `json:"status"`           // 执行状态
    Msg             string         `json:"msg"`              // 错误消息
    CheckList       []RetCheckInfo `json:"check_list"`       // 检查结果列表
}
```

**RetCheckInfo** (`analysis.go:19-32`):

```go
type RetCheckInfo struct {
    CheckId       int    `json:"check_id"`         // 检查项ID
    Security      string `json:"security"`         // 安全等级
    Type          string `json:"type"`             // 类型(英文)
    Title         string `json:"title"`            // 标题(英文)
    Description   string `json:"description"`      // 描述(英文)
    Solution      string `json:"solution"`         // 解决方案(英文)
    TypeCn        string `json:"type_cn"`          // 类型(中文)
    TitleCn       string `json:"title_cn"`         // 标题(中文)
    DescriptionCn string `json:"description_cn"`   // 描述(中文)
    SolutionCn    string `json:"solution_cn"`      // 解决方案(中文)
    Result        int    `json:"result"`           // 检查结果码
    Msg           string `json:"msg"`              // 错误消息
}
```

### 结果码

**定义** (`rule_engine.go:46-52`):

```go
const (
    SuccessCode      = 1   // 检查通过
    FailCode         = 2   // 检查失败
    ErrorCode        = -1  // 通用错误
    ErrorConfigWrite = -2  // 配置错误
    ErrorFile        = -3  // 文件读写异常
)
```

| 结果码 | 名称 | 含义 | 处理建议 |
|--------|------|------|----------|
| 1 | SuccessCode | 检查通过 | 无需处理 |
| 2 | FailCode | 检查失败 | 按 solution 修复 |
| -1 | ErrorCode | 通用错误 | 查看 msg 字段 |
| -2 | ErrorConfigWrite | 配置错误 | 检查 YAML 配置 |
| -3 | ErrorFile | 文件读写异常 | 检查文件权限 |

### JSON 示例

**完整结果**:

```json
{
    "baseline_id": 1200,
    "baseline_version": "1.0",
    "status": "success",
    "msg": "",
    "check_list": [
        {
            "check_id": 1,
            "security": "high",
            "type": "Identification",
            "title": "Ensure password expiration is 90 days or less",
            "description": "The PASS_MAX_DAYS parameter in /etc/login.defs...",
            "solution": "Set PASS_MAX_DAYS parameter to 90 in /etc/login.defs",
            "type_cn": "身份鉴别",
            "title_cn": "设置密码失效时间<=90天",
            "description_cn": "请设置密码失效时间，定期修改密码策略...",
            "solution_cn": "在 /etc/login.defs 中将 PASS_MAX_DAYS 参数设置为 90",
            "result": 2,
            "msg": ""
        },
        {
            "check_id": 2,
            "security": "high",
            "type": "Identification",
            "title": "Ensure minimum days between password changes is 2 or more",
            "description": "...",
            "solution": "...",
            "type_cn": "身份鉴别",
            "title_cn": "密码修改最短周期>=2天",
            "description_cn": "...",
            "solution_cn": "...",
            "result": 1,
            "msg": ""
        }
    ]
}
```

**错误结果**:

```json
{
    "baseline_id": 1200,
    "baseline_version": "",
    "status": "error",
    "msg": "config file not found: config/linux/1200.yaml",
    "check_list": []
}
```

### 上报实现

**源码** (`main.go:32-54`):

```go
func SendServer(retCheckInfo check.RetBaselineInfo, token string) (err error) {
    // 1. 创建 Record
    record := plugins.Record{}
    record.DataType = int32(BaseLineDataType)  // 8000
    record.Timestamp = time.Now().Unix()

    // 2. 序列化结果数据
    dataInfo, err := json.Marshal(retCheckInfo)
    if err != nil {
        return err
    }

    // 3. 构造 Payload
    payload := plugins.Payload{}
    field := make(map[string]string, 0)
    field["data"] = string(dataInfo)  // JSON 字符串
    field["token"] = token              // 任务令牌
    payload.Fields = field
    record.Data = &payload

    // 4. 发送到 Server
    err = pluginClient.SendRecord(&record)
    if err != nil {
        return err
    }

    return nil
}
```

---

## 状态上报协议

### DataType: 8010

用于上报任务执行状态（成功/失败）。

### 数据格式

**Payload Fields**:

| 字段 | 类型 | 说明 |
|------|------|------|
| status | string | 任务状态: "succeed" / "failed" |
| token | string | 任务令牌（与任务接收时的 token 一致） |
| msg | string | 错误消息（失败时填写） |

### 状态值

**定义** (`main.go:17-18`):

```go
var (
    TaskStatusSuccess = "succeed"
    TaskStatusFailed  = "failed"
)
```

### JSON 示例

**成功**:

```json
{
    "status": "succeed",
    "token": "task-uuid-1234-5678",
    "msg": ""
}
```

**失败**:

```json
{
    "status": "failed",
    "token": "task-uuid-1234-5678",
    "msg": "config file not found: config/linux/9999.yaml"
}
```

### 上报实现

**源码** (`main.go:57-73`):

```go
func TaskStatusSendServer(status string, token string, msg string) {
    // 1. 创建 Record
    record := plugins.Record{}
    record.DataType = int32(BaseLineTaskStatusDataType)  // 8010
    record.Timestamp = time.Now().Unix()

    // 2. 构造 Payload
    payload := plugins.Payload{}
    field := make(map[string]string, 0)
    field["status"] = status
    if token != "" {
        field["token"] = token
    }
    field["msg"] = msg
    payload.Fields = field
    record.Data = &payload

    // 3. 发送到 Server（忽略错误）
    _ = pluginClient.SendRecord(&record)
}
```

### 调用时机

**按需扫描**:

```go
// main.go:96-101
if analysisErr != nil {
    TaskStatusSendServer(TaskStatusFailed, pluginsTask.Token, analysisErr.Error())
} else {
    TaskStatusSendServer(TaskStatusSuccess, pluginsTask.Token, "")
}
```

**定时扫描**:

```go
// main.go:146-149
if analysisErr != nil {
    TaskStatusSendServer(TaskStatusFailed, "", analysisErr.Error())
} else {
    TaskStatusSendServer(TaskStatusSuccess, "", "")
}
```

**注意**: 定时扫描的 token 为空字符串。

---

## 错误处理

### 错误分类

| 错误类型 | 返回码 | 示例 |
|---------|--------|------|
| 配置错误 | -2 | YAML 格式错误、规则类型未知 |
| 文件错误 | -3 | 文件不存在、无权限读取 |
| 通用错误 | -1 | 其他未分类错误 |

### 错误码格式

错误消息格式: `错误码:错误描述`

**示例**:
- `-2:unknown rule type:invalid_type`
- `-3:open file /etc/test Error no such file`

### 错误解析

**源码** (`analysis.go:100-113`):

```go
ifPass, err := AnalysisRule(checkInfo.Check)
if err != nil {
    retcheckInfo.Result = ErrorCode  // 默认 -1

    // 解析错误码（前2个字符）
    errCode, _ := strconv.Atoi(err.Error()[:2])

    switch errCode {
    case ErrorFile:  // -3
        retcheckInfo.Result = ErrorFile
        retcheckInfo.Msg = err.Error()[3:]  // 跳过错误码

    case ErrorConfigWrite:  // -2
        retcheckInfo.Result = ErrorConfigWrite
        retcheckInfo.Msg = err.Error()[3:]

    default:  // -1
        retcheckInfo.Result = ErrorCode
        retcheckInfo.Msg = err.Error()
    }
}
```

### 错误示例

#### 配置错误示例

```json
{
    "check_id": 10,
    "result": -2,
    "msg": "unknown rule type:invalid_check"
}
```

**原因**: YAML 中定义了不存在的规则类型

#### 文件错误示例

```json
{
    "check_id": 20,
    "result": -3,
    "msg": "open file /etc/test Error no such file or directory"
}
```

**原因**: 要检查的文件不存在

#### 通用错误示例

```json
{
    "check_id": 30,
    "result": -1,
    "msg": "unexpected error occurred"
}
```

### 错误处理策略

**文件不存在**:
- `file_line_check`: 返回 false（不报错）
- `file_permission`: 返回 true（视为通过）
- `if_file_exist`: 返回 false

**命令执行失败**:
- 默认: 返回 false
- `ignore_exit` 参数: 返回 true

**配置错误**:
- 立即返回错误码 -2
- 记录日志
- 上报错误状态

---

## 日志规范

### 日志配置

**源码** (`infra/log.go`):

```go
var Loger *log.Logger

func init() {
    logFile, err := os.OpenFile("baseline.log",
        os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
    if err != nil {
        panic(err)
    }

    Loger = log.New(logFile,
        "[baseline] ",
        log.Ldate|log.Ltime|log.Lshortfile)
}
```

### 日志格式

```
[baseline] 2024/01/15 10:30:45 main.go:93: sendServer success: 1200
```

**格式说明**:
- `[baseline]`: 日志前缀
- `2024/01/15`: 日期
- `10:30:45`: 时间
- `main.go:93`: 源文件和行号
- `sendServer success: 1200`: 日志消息

### 日志级别

虽然代码中未显式定义级别，但按严重程度可分为：

| 级别 | 使用场景 | 示例 |
|------|---------|------|
| INFO | 正常流程 | `sendServer success` |
| WARN | 非致命错误 | `getTask error` |
| ERROR | 严重错误 | `config file not found` |

### 关键日志点

#### 1. 任务接收

```go
// main.go:81
infra.Loger.Println("getTask error:", err.Error())
```

#### 2. 结果上报

```go
// main.go:91-93
if err != nil {
    infra.Loger.Println("sendServer error:", err)
} else {
    infra.Loger.Println("sendServer success:", retBaselineInfo.BaselineId)
}
```

#### 3. 配置加载

```go
// analysis.go:71
infra.Loger.Println("getBaselineConfigData error:", err)
```

#### 4. 规则执行

```go
// rule_engine.go:287, 299, 316
infra.Loger.Println(err)
```

### 日志查询

**查看最新日志**:

```bash
tail -f baseline.log
```

**过滤成功记录**:

```bash
grep "success" baseline.log
```

**过滤错误记录**:

```bash
grep "error" baseline.log
```

**统计扫描次数**:

```bash
grep "sendServer success" baseline.log | wc -l
```

**查看特定基线的执行**:

```bash
grep "baseline_id.*1200" baseline.log
```

---

## 协议示例

### 完整交互流程

```
1. Server 下发任务
   ↓
   POST /task
   {
       "token": "task-uuid-1234",
       "data": "{\"baseline_id\":1200,\"check_id_list\":[1,2,3]}"
   }

2. Plugin 接收任务
   ↓
   pluginClient.ReceiveTask()

3. Plugin 执行检查
   ↓
   check.Analysis(taskData)

4. Plugin 上报结果 (DataType: 8000)
   ↓
   {
       "DataType": 8000,
       "Timestamp": 1705305045,
       "Data": {
           "Fields": {
               "token": "task-uuid-1234",
               "data": "{\"baseline_id\":1200,\"baseline_version\":\"1.0\",\"status\":\"success\",\"check_list\":[...]}"
           }
       }
   }

5. Plugin 上报状态 (DataType: 8010)
   ↓
   {
       "DataType": 8010,
       "Timestamp": 1705305046,
       "Data": {
           "Fields": {
               "status": "succeed",
               "token": "task-uuid-1234",
               "msg": ""
           }
       }
   }
```

---

## 数据大小估算

### 单个检查项

```json
{
    "check_id": 1,
    "security": "high",
    "type": "Identification",
    "title": "...",  // ~50 bytes
    "description": "...",  // ~200 bytes
    "solution": "...",  // ~150 bytes
    "type_cn": "身份鉴别",  // ~12 bytes
    "title_cn": "...",  // ~30 bytes
    "description_cn": "...",  // ~100 bytes
    "solution_cn": "...",  // ~80 bytes
    "result": 1,
    "msg": ""
}
```

**估算大小**: ~700 bytes

### 完整基线结果

- 120 个检查项 × 700 bytes ≈ 84 KB
- 加上基线元数据: ~85 KB

**结论**: 单次扫描的结果数据约 **85 KB**，网络传输压力较小。

---

## 常见问题

### Q: 结果上报失败怎么办？

A:
1. 检查网络连接
2. 查看 baseline.log 中的错误信息
3. 确认 Elkeid Agent 运行正常
4. 重启插件重新尝试

### Q: 如何验证数据格式是否正确？

A:
```bash
# 查看上报的 JSON 数据
grep "sendServer success" baseline.log -A 5
```

### Q: token 为空会影响结果上报吗？

A: 不会。token 只用于关联任务和结果，为空时 Server 会根据时间戳和数据内容进行关联。定时扫描的 token 固定为空字符串。

### Q: 如何减少结果数据大小？

A:
1. 只上报失败的检查项（需修改代码）
2. 精简 description 和 solution 字段
3. 移除非必要的检查项

---

## 下一步阅读

- **学习配置编写** → [03-基线配置.md](./03-基线配置.md)
- **深入规则引擎** → [02-规则引擎.md](./02-规则引擎.md)
- **理解整体架构** → [01-架构设计.md](./01-架构设计.md)
