# Elkeid 容器资产获取实现详解

## 目录
- [核心代码位置](#核心代码位置)
- [架构设计](#架构设计)
- [数据结构](#数据结构)
- [容器运行时适配](#容器运行时适配)
- [资产获取流程](#资产获取流程)
- [关键技术细节](#关键技术细节)
- [实际应用示例](#实际应用示例)

---

## 核心代码位置

### 文件结构

```
plugins/collector/
├── container.go                    # 容器Handler (调度入口)
└── container/
    ├── container.go                # 容器运行时客户端实现
    └── enum.go                     # 容器状态枚举
```

### 关键文件说明

| 文件 | 行数 | 主要功能 |
|------|------|---------|
| `container.go` | 70 | ContainerHandler 实现，负责调度和数据上报 |
| `container/container.go` | 235 | 容器运行时适配层（Docker、CRI） |
| `container/enum.go` | 25 | 容器状态定义 |

---

## 架构设计

### 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│              ContainerHandler (container.go)                 │
│  每5分钟执行一次                                              │
└────────────────────┬────────────────────────────────────────┘
                     │
                     │ NewClients()
                     ▼
┌─────────────────────────────────────────────────────────────┐
│         容器运行时探测 (container/container.go)              │
│                                                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │  CRI Client  │  │ Docker Client│  │ (未来扩展)    │     │
│  │  (containerd)│  │              │  │              │     │
│  │  (CRI-O)     │  │              │  │              │     │
│  │  (cri-dockerd│  │              │  │              │     │
│  └──────┬───────┘  └──────┬───────┘  └──────────────┘     │
│         │                  │                                │
│         │                  │                                │
└─────────┼──────────────────┼────────────────────────────────┘
          │                  │
          ▼                  ▼
┌──────────────────┐  ┌──────────────────┐
│  gRPC Socket     │  │  Docker Socket   │
│  /run/containerd/│  │  /var/run/       │
│  containerd.sock │  │  docker.sock     │
└──────────────────┘  └──────────────────┘
          │                  │
          ▼                  ▼
┌──────────────────────────────────────────┐
│         Container Runtime                 │
│  (containerd / CRI-O / Docker)           │
└──────────────────────────────────────────┘
```

### 设计特点

1. **多运行时支持**: 自动探测并适配 Docker、containerd、CRI-O 等
2. **统一接口**: 通过 `Client` 接口屏蔽底层差异
3. **高频采集**: 每 5 分钟执行一次（所有 Handler 中频率最高）
4. **进程关联**: 通过 PID Namespace 实现容器与进程的关联

---

## 数据结构

### Container 结构体

**定义** (`container/container.go:38-48`):

```go
type Container struct {
    ID         string  // 容器ID (完整ID)
    Name       string  // 容器名称
    ImageID    string  // 镜像ID (去除 sha256: 前缀)
    ImageName  string  // 镜像名称
    State      string  // 容器状态 (running/created/exited/unknown)
    Pid        string  // 容器主进程PID
    Pns        string  // PID Namespace (用于进程关联)
    Runtime    string  // 运行时类型 (docker/cri)
    CreateTime string  // 创建时间 (Unix时间戳)
}
```

### 状态枚举

**定义** (`container/enum.go:5-17`):

```go
type State int32

const (
    CREATED State = 0
    RUNNING State = 1
    EXITED  State = 2
    UNKNOWN State = 3
)

var StateName = map[int32]string{
    0: "created",
    1: "running",
    2: "exited",
    3: "unknown",
}
```

### Client 接口

**定义** (`container/container.go:32-37`):

```go
type Client interface {
    ListContainers(ctx context.Context) ([]Container, error)  // 列出所有容器
    Exec(ctx context.Context, containerID string, name string, arg ...string) ([]byte, error)  // 在容器中执行命令
    Close()  // 关闭客户端
    Runtime() string  // 返回运行时类型
}
```

---

## 容器运行时适配

### 1. 运行时探测

**NewClients() 函数** (`container/container.go:201-234`):

```go
func NewClients() []Client {
    var clients []Client

    // 1. 尝试探测 CRI 运行时 (containerd, CRI-O, cri-dockerd)
    for _, path := range []string{
        "unix:///run/containerd/containerd.sock",
        "unix:///run/crio/crio.sock",
        "unix:///var/run/cri-dockerd.sock",
    } {
        ctx, cancel := context.WithTimeout(context.Background(), time.Second)

        // 建立 gRPC 连接
        cc, err := grpc.DialContext(ctx, path,
            grpc.WithTransportCredentials(insecure.NewCredentials()),
            grpc.FailOnNonTempDialError(true),
            grpc.WithBlock(),
            grpc.WithReturnConnectionError(),
        )

        if err == nil {
            // 创建 CRI 客户端
            c := cri.NewRuntimeServiceClient(cc)

            // 验证连接（调用 Version 接口）
            _, err := c.Version(context.Background(), &cri.VersionRequest{})
            if err == nil {
                clients = append(clients, &criClient{c: c, cc: cc})
            } else {
                cc.Close()
            }
        }
        cancel()
    }

    // 2. 尝试探测 Docker
    client, err := docker.NewClientWithOpts(
        docker.FromEnv,  // 从环境变量读取配置
        docker.WithAPIVersionNegotiation(),  // 自动协商API版本
    )
    if err == nil {
        clients = append(clients, &dockerClient{c: client})
    }

    return clients
}
```

**探测流程**:

```
1. 尝试连接 containerd socket
   ├─ 成功 → 添加 criClient
   └─ 失败 → 继续

2. 尝试连接 CRI-O socket
   ├─ 成功 → 添加 criClient
   └─ 失败 → 继续

3. 尝试连接 cri-dockerd socket
   ├─ 成功 → 添加 criClient
   └─ 失败 → 继续

4. 尝试连接 Docker
   ├─ 成功 → 添加 dockerClient
   └─ 失败 → 返回已找到的客户端列表
```

### 2. CRI 客户端实现

**ListContainers 方法** (`container/container.go:54-94`):

```go
func (c *criClient) ListContainers(ctx context.Context) ([]Container, error) {
    containers := []Container{}

    // 1. 调用 CRI API 列出所有容器
    resp, err := c.c.ListContainers(ctx, &cri.ListContainersRequest{})
    if err != nil {
        return nil, err
    }

    // 2. 遍历每个容器
    for _, criContainer := range resp.Containers {
        container := Container{
            ID:         criContainer.GetId(),
            Name:       criContainer.GetMetadata().GetName(),

            // 去除 sha256: 前缀
            ImageID:    strings.TrimPrefix(criContainer.GetImageRef(), "sha256:"),
            ImageName:  strings.TrimPrefix(criContainer.GetImage().GetImage(), "sha256:"),

            State:      StateName[int32(criContainer.GetState())],
            CreateTime: strconv.FormatInt(criContainer.CreatedAt/1000000000, 10),
            Runtime:    c.Runtime(),
        }

        // 3. 如果容器正在运行，获取详细信息
        if container.State == StateName[int32(RUNNING)] {
            resp, err := c.c.ContainerStatus(ctx, &cri.ContainerStatusRequest{
                ContainerId: criContainer.Id,
                Verbose:     true,  // 获取详细信息
            })

            if err == nil {
                // 4. 解析进程PID
                if info, ok := resp.Info["info"]; ok {
                    p := struct {
                        Pid int `json:"pid"`
                    }{}
                    if err := json.Unmarshal([]byte(info), &p); err == nil {
                        container.Pid = strconv.Itoa(p.Pid)

                        // 5. 获取 PID Namespace
                        if p.Pid > 0 {
                            if proc, err := process.NewProcess(container.Pid); err == nil {
                                container.Pns, _ = proc.Namespace("pid")
                            }
                        }
                    }
                }

                // 6. 获取真实的镜像名称
                if resp.Status.GetImage().GetImage() != "" {
                    container.ImageName = strings.TrimPrefix(
                        resp.Status.GetImage().GetImage(),
                        "sha256:",
                    )
                }
            }
        }

        containers = append(containers, container)
    }

    return containers, nil
}
```

**关键技术点**:

1. **分两步获取信息**:
   - `ListContainers`: 获取基本信息（快速）
   - `ContainerStatus`: 获取详细信息（慢，只对运行中的容器调用）

2. **PID Namespace 提取**:
   ```go
   proc.Namespace("pid")  // 读取 /proc/[pid]/ns/pid
   ```

3. **镜像名称处理**:
   - 优先使用 `ContainerStatus` 返回的完整镜像名
   - 去除 `sha256:` 前缀

### 3. Docker 客户端实现

**ListContainers 方法** (`container/container.go:130-162`):

```go
func (c *dockerClient) ListContainers(ctx context.Context) ([]Container, error) {
    containers := []Container{}

    // 1. 调用 Docker API 列出所有容器 (包括停止的)
    resp, err := c.c.ContainerList(ctx, types.ContainerListOptions{All: true})
    if err != nil {
        return nil, err
    }

    // 2. 遍历每个容器
    for _, dockerContainer := range resp {
        container := Container{
            ID:         dockerContainer.ID,
            ImageID:    strings.TrimPrefix(dockerContainer.ImageID, "sha256:"),
            ImageName:  strings.TrimPrefix(dockerContainer.Image, "sha256:"),
            State:      dockerContainer.State,
            CreateTime: strconv.FormatInt(dockerContainer.Created, 10),
            Runtime:    c.Runtime(),
        }

        // 3. 调用 Inspect 获取详细信息
        resp, err := c.c.ContainerInspect(ctx, dockerContainer.ID)
        if err == nil {
            // 4. 获取容器名称（去除前导斜杠）
            container.Name = strings.TrimPrefix(resp.Name, "/")

            // 5. 如果容器正在运行，获取PID和Namespace
            if container.State == StateName[int32(RUNNING)] {
                container.Pid = strconv.Itoa(resp.State.Pid)

                if resp.State.Pid > 0 {
                    if p, err := process.NewProcess(container.Pid); err == nil {
                        container.Pns, _ = p.Namespace("pid")
                    }
                }
            }
        }

        // 6. 兜底：如果名称为空，使用 Names 数组的第一个元素
        if container.Name == "" && len(dockerContainer.Names) > 0 {
            container.Name = dockerContainer.Names[0]
        }

        containers = append(containers, container)
    }

    return containers, nil
}
```

**Docker API 调用**:

1. **ContainerList**:
   - 参数: `All: true` 包含所有状态的容器
   - 返回: 容器列表（基本信息）

2. **ContainerInspect**:
   - 参数: 容器ID
   - 返回: 容器详细信息（包括 PID、Name、State 等）

---

## 资产获取流程

### ContainerHandler 执行流程

**Handle 方法** (`container.go:34-69`):

```go
func (h *ContainerHandler) Handle(c *plugins.Client, cache *engine.Cache, seq string) {
    // 1. 获取所有运行时客户端
    clients := container.NewClients()

    // 2. 遍历每个运行时
    for _, client := range clients {
        // 3. 列出该运行时下的所有容器
        containers, err := client.ListContainers(context.Background())
        client.Close()

        if err != nil {
            continue  // 该运行时不可用或出错，跳过
        }

        // 4. 遍历每个容器
        for _, ctr := range containers {
            // 5. 构造 Record 并上报
            c.SendRecord(&plugins.Record{
                DataType:  int32(h.DataType()),  // 5056
                Timestamp: time.Now().Unix(),
                Data: &plugins.Payload{
                    Fields: map[string]string{
                        "id":          ctr.ID,
                        "name":        ctr.Name,
                        "state":       ctr.State,
                        "image_id":    ctr.ImageID,
                        "image_name":  ctr.ImageName,
                        "pid":         ctr.Pid,
                        "pns":         ctr.Pns,
                        "runtime":     ctr.State,
                        "create_time": ctr.CreateTime,
                        "package_seq": seq,
                    },
                },
            })

            // 6. 缓存运行中容器的 Pns (用于进程/端口关联)
            if ctr.State == container.StateName[int32(container.RUNNING)] &&
               ctr.Pns != "" &&
               process.PnsDiffWithRpns(ctr.Pns) {

                cache.Put(h.DataType(), ctr.Pns, map[string]string{
                    "container_id":   ctr.ID,
                    "container_name": ctr.Name,
                })
            }
        }
    }
}
```

### 数据流图

```
1. 定时触发 (每5分钟)
   ↓
2. NewClients()
   ├─ containerd socket 探测
   ├─ CRI-O socket 探测
   ├─ cri-dockerd socket 探测
   └─ Docker 探测
   ↓
3. 收集到的客户端列表: [criClient, dockerClient]
   ↓
4. 遍历每个客户端
   ↓
5. client.ListContainers()
   ├─ CRI: c.ListContainers()
   │   ├─ 调用 gRPC 接口
   │   ├─ 解析容器信息
   │   └─ 提取 PID Namespace
   │
   ├─ Docker: c.ContainerList() + c.ContainerInspect()
   │   ├─ 调用 HTTP API
   │   ├─ 解析容器信息
   │   └─ 提取 PID Namespace
   ↓
6. 遍历容器列表
   ↓
7. 构造 Record
   ├─ 填充容器字段
   └─ 发送到 Agent
   ↓
8. 缓存容器信息 (用于进程/端口关联)
   cache.Put(5056, pns, {container_id, container_name})
```

---

## 关键技术细节

### 1. PID Namespace 的作用

**定义**: Linux PID Namespace 是容器隔离的基础，每个容器有独立的 PID 命名空间。

**获取方法** (`process` 包):

```go
// 读取 /proc/[pid]/ns/pid 符号链接
func (p *Process) Namespace(name string) (string, error) {
    path := filepath.Join("/proc", p.Pid(), "ns", name)
    target, err := os.Readlink(path)
    if err != nil {
        return "", err
    }
    // target 格式: "pid:[4026532448]"
    return target, nil
}
```

**实际值示例**:
```
pid:[4026531836]  # Host 进程
pid:[4026532448]  # 容器A的进程
pid:[4026532512]  # 容器B的进程
```

**用途**: 作为 Cache Key，实现容器与进程/端口的关联

### 2. 容器与进程关联

**ProcessHandler 中的关联逻辑** (`process.go:58-60`):

```go
// 通过进程的 PID Namespace 查询容器信息
ns, _ := p.Namespaces()
m, _ := cache.Get(5056, ns.Pid)  // 从 Cache 查询

rec.Data.Fields["container_id"] = m["container_id"]
rec.Data.Fields["container_name"] = m["container_name"]
```

**流程**:
```
1. ContainerHandler 执行
   ├─ 获取容器列表
   ├─ 提取容器的 PID Namespace
   └─ 存入 Cache: cache.Put(5056, pns, {id, name})

2. ProcessHandler 执行
   ├─ 枚举进程
   ├─ 获取进程的 PID Namespace
   ├─ 查询 Cache: cache.Get(5056, pns)
   └─ 填充 container_id 和 container_name 字段
```

### 3. 镜像ID与镜像名称

**ImageID vs ImageName**:

| 字段 | 来源 | 示例 | 说明 |
|------|------|------|------|
| ImageID | `ImageRef` / `ImageID` | `a4bdda7d42f0` | 镜像的唯一标识符（SHA256的前12位） |
| ImageName | `Image` / `Image.Image` | `nginx:1.21` | 用户可读的镜像名称和标签 |

**处理逻辑**:

```go
// CRI
ImageID:   strings.TrimPrefix(criContainer.GetImageRef(), "sha256:")
ImageName: strings.TrimPrefix(criContainer.GetImage().GetImage(), "sha256:")

// Docker
ImageID:   strings.TrimPrefix(dockerContainer.ImageID, "sha256:")
ImageName: strings.TrimPrefix(dockerContainer.Image, "sha256:")
```

**去除前缀的原因**: 统一格式，方便存储和查询

### 4. 容器状态映射

**CRI 状态 → 标准状态**:

```go
StateName[int32(criContainer.GetState())]
```

**Docker 状态直接使用**:

```go
State: dockerContainer.State  // "running", "created", "exited" 等
```

### 5. 时间戳处理

**CRI 时间戳**:

```go
// CRI 返回的是纳秒级时间戳，需要转换为秒
CreateTime: strconv.FormatInt(criContainer.CreatedAt/1000000000, 10)
```

**Docker 时间戳**:

```go
// Docker 返回的已经是秒级时间戳
CreateTime: strconv.FormatInt(dockerContainer.Created, 10)
```

---

## 实际应用示例

### 示例1: 采集结果

**上报的容器数据** (DataType: 5056):

```json
{
  "id": "a4bdda7d42f0e0c8d60d...",
  "name": "nginx-proxy",
  "state": "running",
  "image_id": "a4bdda7d42f0e0c8d60d...",
  "image_name": "nginx:1.21",
  "pid": "12345",
  "pns": "pid:[4026532448]",
  "runtime": "docker",
  "create_time": "1640000000",
  "package_seq": "abc123..."
}
```

### 示例2: 多运行时环境

**场景**: 主机上同时运行 Docker 和 containerd

```
Host
├── Docker 容器
│   ├── nginx (ID: abc123...)
│   └── mysql (ID: def456...)
└── containerd 容器 (K8s)
    ├── kube-proxy (ID: ghi789...)
    └── coredns (ID: jkl012...)
```

**采集结果**: 4个容器记录，runtime 字段分别为 `docker` 和 `cri`

### 示例3: 容器与进程关联

**容器信息** (ContainerHandler):

```json
{
  "id": "abc123",
  "name": "nginx",
  "pns": "pid:[4026532448]",
  ...
}
```

**进程信息** (ProcessHandler):

```json
{
  "pid": "12345",
  "exe": "/usr/sbin/nginx",
  "pid_ns": "pid:[4026532448]",
  "container_id": "abc123",        // 自动关联
  "container_name": "nginx",       // 自动关联
  ...
}
```

### 示例4: Kubernetes 环境

**Pod 中的容器**:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: web-app
spec:
  containers:
  - name: nginx
    image: nginx:1.21
  - name: sidecar
    image: busybox:latest
```

**采集结果**: 2个容器记录

```json
[
  {
    "id": "xxx",
    "name": "nginx",
    "image_name": "nginx:1.21",
    "state": "running",
    "runtime": "cri"
  },
  {
    "id": "yyy",
    "name": "sidecar",
    "image_name": "busybox:latest",
    "state": "running",
    "runtime": "cri"
  }
]
```

---

## 总结

### 核心技术栈

- **CRI (Container Runtime Interface)**: Kubernetes 标准容器运行时接口
- **Docker API**: Docker 原生 HTTP API
- **gRPC**: CRI 使用的通信协议
- **Linux Namespace**: 容器隔离和进程关联的基础

### 设计优势

1. **自动探测**: 无需配置，自动发现可用的容器运行时
2. **多运行时支持**: 同时支持 Docker、containerd、CRI-O 等
3. **统一抽象**: 通过 `Client` 接口屏蔽底层差异
4. **高效关联**: 通过 PID Namespace 实现容器与进程的关联
5. **数据完整**: 采集容器ID、名称、镜像、状态、PID等完整信息

### 关键代码行

| 功能 | 代码位置 |
|------|---------|
| 运行时探测 | `container/container.go:201-234` |
| CRI 容器列表 | `container/container.go:54-94` |
| Docker 容器列表 | `container/container.go:130-162` |
| 容器信息上报 | `container.go:34-69` |
| 容器-进程关联 | `container.go:61-66` |

### 数据流向

```
容器运行时 → Client.ListContainers() → ContainerHandler → Record → Agent → Server
                                             ↓
                                          Cache (PID Namespace)
                                             ↓
                                      ProcessHandler (关联容器信息)
```

这就是 Elkeid 获取容器资产（容器ID、镜像等）的完整实现机制！
